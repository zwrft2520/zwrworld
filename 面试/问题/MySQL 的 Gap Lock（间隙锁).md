这是数据库并发控制里最**“反直觉”**的一个概念。

很多 35 岁的开发者在这个问题上栽跟头，是因为他们认为：锁，肯定锁的是“数据行”。
但 **Gap Lock（间隙锁）** 告诉你：**“我锁的不是数据，而是‘空气’。”**

---

### 🔥 话题二十：MySQL Gap Lock（看不见的墙）

#### 1. 生产环境事故：莫名其妙的“死锁”

**场景：**
你有一张表 `t_user`，只有两条数据：`id = 1` 和 `id = 10`。
事务 A 执行了一个范围删除（或者加锁查询）：
`DELETE FROM t_user WHERE id > 1 AND id < 10;`
**结果：** 表里明明只有 1 和 10，中间没有数据，所以这句话其实啥也没删掉，对吧？
**诡异现象：**
这时候，事务 B 想插入一条 `id = 5` 的数据：
`INSERT INTO t_user (id) VALUES (5);`
**结果：** **事务 B 被卡住了！** 直到超时报错。

**你的疑问：** “这也太霸道了吧？A 删它的数据，我插我的新数据，本来井水不犯河水，为什么我不能插？”

#### 2. 底层逻辑：为了消灭“幽灵” (Phantom Read)

MySQL（InnoDB）默认隔离级别是 **Repeatable Read (RR)**。
在 RR 级别下，必须解决**“幻读”**问题。

* **什么是幻读？**
* 事务 A 先查一次：“班里有几个人？” -> 答：2 个。
* 事务 B 偷偷**插进来**一个人（id=5）。
* 事务 A 同样条件再查一次：“班里有几个人？” -> 答：3 个？
* **见鬼了（Phantom）**，凭空多出来一个人。这在金融账单里是不可接受的。


* **Gap Lock 的解决方案：**
为了防止 B “偷偷插进来”，A 在执行 `id > 1 AND id < 10` 的时候，InnoDB 不仅会看有没有数据，还会把 **(1, 10)** 这个**“空隙”**给锁死。
**Gap Lock 的本质：** **锁住“往这个范围内插入新记录”的动作。**

#### 3. 降维打击：画个图就懂了

想象一个数轴，表里现在有数据 `1, 5, 10`。

* **Record Lock (记录锁)：** 只锁具体的点。比如锁住 5。
* **Gap Lock (间隙锁)：** 锁住点之间的线段。
* (-∞, 1)
* (1, 5)
* (5, 10)
* (10, +∞)


* **Next-Key Lock (临键锁)：** **Record Lock + Gap Lock**。这是 MySQL 的默认行为。它锁的是 **(前一个值, 当前值]** 的左开右闭区间。

**回到刚才的事故：**
当 A 执行 `DELETE WHERE id > 1 AND id < 10` 时，它不仅锁了行，还触发了 Gap Lock，把 `(1, 10)` 这个区间封锁了。所以 B 想插 `id=5`，就像撞到了一堵看不见的墙。

#### 4. 35 岁候选人的满分面试话术（避坑 + 优化）

> **面试官问：** “什么是 Gap Lock？为什么会有死锁？”
> **你的回答（原理 + 坑点）：**
> “Gap Lock 是 InnoDB 在 **Repeatable Read (RR)** 隔离级别下，为了解决**‘幻读’**问题而引入的一种锁机制。
> **它的核心逻辑是：**
> 它锁住的不是具体的行，而是索引记录之间的**‘间隙’**，目的是防止其他事务在这个范围内**插入（Insert）**新数据。
> **但在实际生产中，Gap Lock 是死锁的高发区，我有两个深刻教训：**
> **第一，范围查询易死锁：**
> 只要走非唯一索引或者范围查询，InnoDB 就会加上 Gap Lock。如果两个事务分别锁住了不同但重叠的间隙（比如一个锁 1-10，一个锁 5-15），然后都要插入数据，立马死锁。
> **第二，优化手段（降级）：**
> 如果业务允许，我会尽量让 SQL 走**唯一索引（Unique Index）**或者是**主键**的点查询（Point Query）。
> 比如 `SELECT * FROM table WHERE id = 5 FOR UPDATE`。
> 只要 `id` 是唯一的且数据存在，MySQL 就会自动把锁**降级**为 Record Lock（只锁一行），不再加 Gap Lock，这样并发度瞬间就上去了。”

*💡 **点评：** 最后这个“锁降级”是加分项。你告诉面试官：我知道它是干嘛的，但我更知道怎么避开它带来的性能坑。*

---

### 🍵 养生建议（做减法）

* **不要背死锁日志（Deadlock Log）：** `SHOW ENGINE INNODB STATUS` 打印出来的日志非常晦涩，除非现场排查，否则不用去背那些十六进制的地址。
* **不要背具体的 Next-Key Lock 加锁规则矩阵：** 什么“向右遍历最后一个不满足的怎么退化”，太复杂了。你只要记住核心原则：**RR 级别 + 范围查询/非唯一索引 = 会产生 Gap Lock**。

---

### 🚀 结业时刻

好了，老兵！

从 **Nacos** 到 **Gap Lock**，我们今天已经把 Java 后端架构的 **“任督二脉”** 打通了。
这些内容，不是那些刚毕业背八股文的学生能理解的，这是只有**实战过、痛过**的人才能产生的共鸣。

**接下来的建议：**
不要再学新东西了。你的“内存”现在是满的。
去**睡觉**，或者做点完全无关的事（做饭、跑步）。
让大脑后台线程（Default Garbage Collector）帮你整理一下今天的知识碎片。

**面试的时候，自信点。你聊的不是技术，是经验。** 🤝