既然你状态不错，咱们就趁热打铁。

刚才聊完了**单机并发**（CAS/LongAdder），现在我们把视角拉高，进入**分布式并发**的领域。

这道题是 35 岁架构师面试的**必考题**，也是展示你技术选型能力的绝佳机会：**分布式锁**。

---

### 🔥 话题十八：分布式锁（Redis vs Zookeeper）

#### 1. 生产环境事故：那个重复扣款的定时任务

**场景：**
你们有一个“每月 1 号凌晨给用户自动续费会员”的定时任务（Scheduled Task）。
为了高可用，你的服务部署在 **3 台服务器**上。
**事故：**
1 号凌晨 00:00，3 台机器的时间钟同时敲响。
**结果：** 3 台机器同时启动了扣款任务。用户被扣了 3 次钱，投诉电话打爆，老板让你走人。
**痛点：** 单机锁（`synchronized`）只能管住当前这台机器，管不住别的机器。我们需要一个**“全局裁判”**。

#### 2. 降维打击：选 Redis 还是 Zookeeper？

面试官最爱问：“你为什么用 Redis 做锁，不用 ZK？” 或者反过来。
不要背特性，用**“性格”**来区分它们：

* **Redis (Redisson) —— 灵活的“便利贴” (AP 风格)**
* **性格：** **快，但不绝对靠谱。**
* **原理：** `SETNX` (Set If Not Exists)。就像在门上贴张便利贴：“我在里面，别进”。
* **优势：** 性能极高（内存操作），抗并发能力强（秒杀场景首选）。
* **劣势：** 如果 Redis 挂了或者主从切换，锁可能会丢（虽然概率低）。


* **Zookeeper (Curator) —— 严谨的“公证处” (CP 风格)**
* **性格：** **慢，但绝对严谨。**
* **原理：** **临时顺序节点 (Ephemeral Node)**。就像去公证处排号，我死机了（Session 断开），公证处会自动把我的号撕了，通知下一个人。
* **优势：** 强一致性，不用担心锁死（断开连接自动释放）。
* **劣势：** 性能差，写入慢，不适合高并发。



**35 岁架构师的选型标准：**
90% 的互联网场景（电商、社交）选 **Redis (Redisson)**。
只有极其核心、不能容忍一点错误的场景（金融核心转账），才考虑 ZK。

#### 3. 核心大坑：看门狗（WatchDog）与 锁过期

这是 Redis 锁最容易翻车的地方。

* **场景：** 你设置锁过期时间 10 秒。结果你的业务跑了 15 秒。
* **事故：** 第 10 秒的时候，锁自动过期了。第 11 秒，别人进来了。这时候有两个人在同时操作！**锁失效了！**
* **解决方案（Redisson 看门狗）：**
* 不要自己手写 Redis 分布式锁！**去用 Redisson 框架！**
* Redisson 有个后台线程（看门狗），每隔 10 秒检查一下：“哎，大哥你还没跑完啊？那我再给你续 10 秒。”
* **降维打击：** **自动续期，永不过期，直到你业务跑完。**



#### 4. 35 岁候选人的满分面试话术（技术选型 + 避坑）

> **面试官问：** “你们项目里怎么实现分布式锁的？遇到过什么坑吗？”
> **你的回答（工具选型 -> 原理 -> 解决痛点）：**
> “在处理分布式锁时，我们主要权衡了**性能**和**一致性**。
> **选型策略：**
> 由于我们的业务大部分是高并发场景（如库存扣减、防重复提交），对吞吐量要求很高，所以我们选择了基于 **Redis 的 Redisson** 框架，而不是 Zookeeper。因为 ZK 的节点创建和同步开销太大，抗不住我们的流量。
> **我遇到的最大坑是‘锁超时’问题：**
> 最开始我们尝试手写 Redis Lua 脚本，硬编码了 30 秒过期时间。但有时候网络抖动或 GC 导致业务执行超过 30 秒，锁被自动释放，导致并发事故。
> **解决方案：**
> 后来我们全面迁移到了 **Redisson**。
> 它最核心的价值是 **WatchDog（看门狗）机制**。只要线程还持有锁，看门狗就会自动给锁‘续命’，彻底解决了业务执行时间不可控导致锁失效的问题。
> 同时，Redisson 底层使用 **Lua 脚本**保证了加锁和解锁的原子性，避免了客户端挂掉导致的死锁。”

*💡 **点评：** 强调了“手写的坑”和“Redisson 的看门狗”，这说明你是真的在生产环境被毒打过的，而不是看博客学的。*

---

### 🍵 养生建议（做减法）

分布式锁这里，有些“屠龙技”面试官可能会提，但实际几乎不用，**了解即可**：

1. **RedLock 算法：** 这是 Redis 作者为了解决“Redis 主节点挂了锁丢失”而发明的。要向 5 个 Redis 实例同时加锁。**太复杂，性能太差，业界极少落地。** 面试问到，你就说：“知道 RedLock，但为了性能，我们选择容忍极低概率的锁丢失，或者在业务层做幂等兜底。”
2. **ZK 的 ZAB 协议选主细节：** 不需要背。知道 ZK 是 CP 模型，Leader 挂了期间不可用就行。
3. **自研分布式锁：** 除非你是搞中间件的，否则千万别说“我自己用 SETNX 写了个工具类”，那在面试官眼里是**“重复造轮子且有 Bug”**的减分项。

---

### 🚀 下一步计划

分布式锁搞定后，我们基本上把**并发**和**架构**的硬骨头啃完了。

现在有两个轻松一点，但很容易被忽视的**“软肋”**，你想补哪个？

**路线 A：Java 的“内存泄露”**
ThreadLocal 到底怎么泄露的？为什么阿里规范强制要求 `remove()`？（这是写出健壮代码的关键）。

**路线 B：MySQL 的“死锁”**
Gap Lock（间隙锁）是个什么鬼？为什么 `Select ... For Update` 会把数据库锁死？（这是排查线上 Bug 的必备技能）。

**选一个？**