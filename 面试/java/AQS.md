**AQS (AbstractQueuedSynchronizer)** 是 Java 并发包 (`java.util.concurrent`, 简称 JUC) 中**最核心、最底层**的基础框架。

如果把 JUC 包比作一辆汽车，那 `ReentrantLock`、`CountDownLatch`、`Semaphore` 这些是我们看得到的方向盘和轮胎，而 **AQS 就是这辆车的“发动机”和“底盘”**。

面试官问 AQS，其实是在问：**“Java 里的锁和同步器，到底是怎么实现的？”**

我们用**“降维打击”**的方式，通过三个维度来拆解它。

---

### 1. 核心模型：一个状态 + 一个队列

AQS 的内部极其简单，它主要就维护了两样东西：

#### A. 资源状态 (`volatile int state`)

这是 AQS 的灵魂。它用一个 `int` 类型的变量 `state` 来表示资源的状态。

* **0**：表示资源空闲，谁都可以抢。
* **1 (或 >1)**：表示资源被占用了。
* 由于它是 `volatile` 的，保证了所有线程都能立刻看到它的变化。

#### B. 等待队列 (CLH 变体队列)

这是一个**双向链表**。

* 当有线程想抢资源，但发现 `state != 0` (被占了) 时，AQS 不会让这个线程直接死掉，而是把它**封装成一个 Node 节点**，扔到这个队列里去**排队（阻塞/挂起）**。
* 等到持有锁的线程干完活了，AQS 会去唤醒队列头部的那个线程：“嘿，轮到你了，起来干活。”

---

### 2. 运作流程：银行柜台的比喻

想象一个**只有一个窗口**的银行柜台：

1. **抢占资源 (tryAcquire)：**
* **线程 A** 来了，一看柜台没人 (`state=0`)。
* 它用 **CAS (原子操作)** 把 `state` 改成 `1`。
* **结果：** 线程 A 办理业务，它是现在的“主人” (`exclusiveOwnerThread`)。


2. **排队等待 (addWaiter)：**
* **线程 B** 来了，一看 `state=1` (有人在办业务)。
* AQS 说：“你别急，去后面的休息区排队。”
* **结果：** 线程 B 被封装成 Node，放入**等待队列**，并被 `LockSupport.park()` **挂起** (睡觉，不耗 CPU)。


3. **释放唤醒 (release)：**
* **线程 A** 办完事了，把 `state` 改回 `0`。
* AQS 去看队列：“谁在排队？” 发现了线程 B。
* **结果：** 唤醒线程 B。线程 B 醒来，发现 `state=0` 了，赶紧上位，把 `state` 改成 `1`。



---

### 3. 设计模式：模板方法模式 (Template Method)

这是 AQS 最精髓的地方。
**AQS 是一个抽象类**，它不知道你具体的“锁规则”是什么（是独占？还是共享？是可重入？还是不可重入？）。

它只负责**脏活累活**（排队、阻塞、唤醒），而把**核心业务逻辑**留给子类去实现。这就是**模板方法模式**。

**子类只需要实现这几个方法：**

* `tryAcquire(int)`: 尝试获取资源（比如：怎么才算抢到锁？）。
* `tryRelease(int)`: 尝试释放资源。
* `tryAcquireShared(int)`: 共享方式获取（如信号量）。
* `tryReleaseShared(int)`: 共享方式释放。

**看看大佬们是怎么利用 AQS 的：**

| 同步器 | AQS 的 `state` 代表什么？ |
| --- | --- |
| **ReentrantLock** | **锁的持有次数**。0=无锁，1=持有，2=重入两次。 |
| **CountDownLatch** | **倒计时的数值**。比如初始化为 5，每次 `countDown()` 就减 1，减到 0 就唤醒所有等待者。 |
| **Semaphore** | **剩余许可证的数量**。初始化为 10，来一个线程减 1，减到 0 后面的就要排队。 |
| **ReentrantReadWriteLock** | 把 32 位的 int 切开，**高 16 位记读锁，低 16 位记写锁**。 |

### 总结 (满分话术)

> **面试官：** “请介绍一下 AQS。”
> **你：**
> “AQS (AbstractQueuedSynchronizer) 是 JUC 包下的核心基础框架，它是构建 ReentrantLock、CountDownLatch 等同步组件的基石。
> **它的核心原理可以概括为‘状态+队列’：**
> 它维护了一个 `volatile int state` 变量来表示同步状态，以及一个 **FIFO 的双向队列**来存储等待锁的线程。
> **它的工作机制是：**
> 线程通过 **CAS** 原子操作去改变 `state`。如果修改成功，就代表获取锁成功；如果失败，AQS 会负责将该线程封装成节点加入队列，并将其挂起等待被唤醒。
> **在设计模式上：**
> 它采用了**模板方法模式**。AQS 把排队、阻塞等通用逻辑都写好了，子类（如 ReentrantLock）只需要实现 `tryAcquire` 等钩子方法来定义‘什么是获取成功’即可，极大地减少了开发锁的难度。”
