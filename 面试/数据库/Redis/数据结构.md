Redis 提供了多种数据类型，每种类型都有其特定的使用场景、底层实现原理和常用方法。

### 1. 字符串 (String)

*   **描述**：Redis 最基本的数据类型，可以存储文本、数字或二进制数据。一个键最多可以关联 512MB 的字符串值。
*   **底层原理**：
    *   如果字符串是纯数字，并且能用 `long` 类型表示，Redis 会将其存储为整数类型，以节省空间。
    *   否则，Redis 会使用自定义的 `sdshdr` (Simple Dynamic String) 结构来存储字符串。`sdshdr` 包含了字符串的长度、已用空间和实际字符数组，这使得字符串操作（如追加）效率更高，并且避免了传统的 C 字符串长度限制和缓冲区溢出问题。
*   **常用方法**：
    *   `SET key value`：设置键值对。
    *   `GET key`：获取键的值。
    *   `INCR key`：将键的值原子性地加 1（如果值为数字）。
    *   `DECR key`：将键的值原子性地减 1（如果值为数字）。
    *   `APPEND key value`：将值追加到现有字符串的末尾。
    *   `STRLEN key`：获取字符串的长度。
    *   `GETRANGE key start end`：获取字符串的子字符串。

### 2. 列表 (List)

*   **描述**：一个有序的字符串元素集合，元素可以重复。列表的左右两边都可以进行插入和弹出操作，因此可以作为队列或栈使用。
*   **底层原理**：
    *   在 Redis 3.2 之前，当列表元素较少且每个元素都较小的时候，列表使用 `ziplist` (压缩列表) 实现，它是一个连续内存块，节省空间。
    *   当元素数量或大小超过 `ziplist` 的限制时，会转换为 `linkedlist` (双向链表) 实现。
    *   从 Redis 3.2 开始，列表主要使用 `quicklist` (快速列表) 实现。`quicklist` 是一个由 `ziplist` 组成的双向链表，它结合了 `ziplist` 的内存效率和 `linkedlist` 的随机访问性能。
*   **常用方法**：
    *   `LPUSH key value [value ...]`：将一个或多个值插入到列表的头部。
    *   `RPUSH key value [value ...]`：将一个或多个值插入到列表的尾部。
    *   `LPOP key`：移除并返回列表的头部元素。
    *   `RPOP key`：移除并返回列表的尾部元素。
    *   `LRANGE key start stop`：获取指定范围内的元素。
    *   `LINDEX key index`：通过索引获取列表中的元素。
    *   `LLEN key`：获取列表的长度。

### 3. 哈希 (Hash)

*   **描述**：一个键值对的集合。在 Redis 中，哈希是一个字符串类型的 field 和 value 之间的映射表，特别适合存储对象。
*   **底层原理**：
    *   当哈希的 field 数量较少且每个 field 和 value 的长度都较小时，使用 `ziplist` (压缩列表) 实现，以节省内存。
    *   当 field 数量或 field/value 长度超过 `ziplist` 的限制时，会转换为 `hashtable` (哈希表，即字典 `dict`) 实现。
*   **常用方法**：
    *   `HSET key field value [field value ...]`：设置哈希表中一个或多个字段的值。
    *   `HGET key field`：获取哈希表中指定字段的值。
    *   `HMSET key field value [field value ...]`：设置多个字段的值（已废弃，建议使用 HSET）。
    *   `HMGET key field [field ...]`：获取多个字段的值。
    *   `HGETALL key`：获取哈希表中所有字段和值。
    *   `HDEL key field [field ...]`：删除哈希表中一个或多个字段。
    *   `HEXISTS key field`：检查哈希表中是否存在指定字段。
    *   `HLEN key`：获取哈希表中字段的数量。

### 4. 集合 (Set)

*   **描述**：一个无序的、不重复的字符串元素集合。可以进行并集、交集、差集等操作。
*   **底层原理**：
    *   当集合中只包含整数元素，并且元素数量较少时，使用 `intset` (整数集合) 实现，它是一个有序、无重复的整数数组，节省空间。
    *   在其他情况下，使用 `hashtable` (哈希表) 实现，其中哈希表的键是集合元素，值是 NULL。
*   **常用方法**：
    *   `SADD key member [member ...]`：向集合中添加一个或多个成员。
    *   `SMEMBERS key`：获取集合中的所有成员。
    *   `SISMEMBER key member`：检查成员是否是集合的成员。
    *   `SREM key member [member ...]`：移除集合中的一个或多个成员。
    *   `SCARD key`：获取集合的成员数量。
    *   `SUNION key [key ...]`：计算多个集合的并集。
    *   `SINTER key [key ...]`：计算多个集合的交集。
    *   `SDIFF key [key ...]`：计算多个集合的差集。

### 5. 有序集合 (Sorted Set / ZSet)

*   **描述**：与集合类似，但每个成员都关联一个浮点数 `score`，集合中的成员是唯一的，但分数可以重复。成员按照分数从小到大排序。
*   **底层原理**：
    *   当有序集合的成员数量较少且每个成员长度较小时，使用 `ziplist` (压缩列表) 实现。
    *   在其他情况下，使用 `skiplist` (跳跃表) 和 `hashtable` (哈希表) 组合实现：
        *   `skiplist` (跳跃表)：用于根据分数范围快速查找成员，并保持成员的有序性。
        *   `hashtable` (哈希表)：用于存储成员到其分数的映射，实现 O(1) 时间复杂度的成员查找和分数更新。
*   **常用方法**：
    *   `ZADD key score member [score member ...]`：向有序集合添加一个或多个成员，或更新已有成员的分数。
    *   `ZRANGE key start stop [WITHSCORES]`：获取指定索引范围内的成员（按分数从小到大排序）。
    *   `ZREVRANGE key start stop [WITHSCORES]`：获取指定索引范围内的成员（按分数从大到小排序）。
    *   `ZRANGEBYSCORE key min max [WITHSCORES]`：获取指定分数范围内的成员。
    *   `ZSCORE key member`：获取成员的分数。
    *   `ZREM key member [member ...]`：移除有序集合中的一个或多个成员。
    *   `ZCARD key`：获取有序集合的成员数量。
    *   `ZINCRBY key increment member`：增加成员的分数。

### 其他数据类型简述

*   **地理空间 (Geospatial)**：基于有序集合实现，通过 Geohash 算法将经纬度编码为 52 位的整数，然后存储在 ZSet 中，利用 ZSet 的范围查询功能实现地理位置查询。
    *   常用方法：`GEOADD`, `GEODIST`, `GEORADIUS`.
*   **HyperLogLog**：一种概率数据结构，用于估算集合中不重复元素的数量，占用固定且非常小的内存（12KB），但有一定误差。
    *   常用方法：`PFADD`, `PFCOUNT`, `PFMERGE`.
*   **位图 (Bitmap)**：实际上是字符串的一种特殊用法，可以将字符串看作是二进制位的数组，对位进行操作。
    *   常用方法：`SETBIT`, `GETBIT`, `BITCOUNT`, `BITOP`.
*   **流 (Stream)**：Redis 5.0 引入的全新数据类型，类似于消息队列，支持多播、消息消费组等功能。
    *   常用方法：`XADD`, `XRANGE`, `XREAD`, `XGROUP`, `XACK`.

这些数据类型构成了 Redis 强大而灵活的基础，使其能够胜任多种应用场景。