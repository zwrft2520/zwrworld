MySQL 中的**索引跳跃（Index Skip Scan）**是 MySQL 8.0 版本引入的一项优化，它允许优化器在某些特定情况下跳过复合索引（联合索引）的前导列，直接使用索引的后续列来访问数据，从而提高查询性能。

### 什么是索引跳跃？

通常，要有效利用复合索引，查询条件必须从索引的最左侧列开始匹配。如果查询条件跳过了索引的前导列，或者只指定了索引的非前导列，那么这个索引通常无法被完全利用，或者只能利用到部分前缀。

索引跳跃打破了这一限制。它允许查询优化器识别出即使索引的前导列在 `WHERE` 子句中没有被指定，或者被指定为 `IN` 列表中的多个值，但只要后续列上有过滤条件，优化器就可以通过“跳过”前导列的值来使用索引。

**核心思想：**
当索引的前导列存在少量不同的值时，优化器可以对每个前导列的值进行“跳跃”，然后为每个跳过的值，使用索引的后续部分进行查找和过滤。这就像对前导列的每个独立值，分别执行了一个更精细的索引查找。

### 什么时候会出现（启用）索引跳跃？

索引跳跃优化会在满足以下条件时被 MySQL 优化器自动考虑和使用：

1.  **复合索引（联合索引）：** 必须存在一个复合索引。
2.  **查询条件涉及索引的非前导列：** `WHERE` 子句中包含索引的非前导列的条件。
3.  **索引前导列未被指定或在 `IN` 列表中：**
    *   索引的**前导列（或部分前导列）在 `WHERE` 子句中未被指定**，或者
    *   索引的**前导列（或部分前导列）在 `WHERE` 子句中使用了 `IN()` 操作符**，并且 `IN` 列表的值数量相对较少。
4.  **查询不涉及索引前导列的范围扫描（除 `IN` 以外）：** 如果前导列有 `LIKE` 或范围查询（例如 `>`, `<`, `BETWEEN`），则通常无法使用索引跳跃。
5.  **索引前导列的唯一值数量相对较少：** 这是关键。如果前导列的唯一值非常多，那么对每个值进行跳跃查找的开销可能会非常大，优化器就不会选择此策略。

**示例：**

假设有一个表 `orders`，包含 `region`、`product_id` 和 `order_date` 字段，并在 `(region, product_id, order_date)` 上创建了一个复合索引 `idx_region_prod_date`。

```sql
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    region VARCHAR(50),
    product_id INT,
    order_date DATE,
    quantity INT
);

CREATE INDEX idx_region_prod_date ON orders (region, product_id, order_date);
```

考虑以下查询：

```sql
SELECT * FROM orders WHERE product_id = 101 AND order_date >= '2025-01-01';
```

在这个查询中：
*   索引是 `(region, product_id, order_date)`。
*   `region` 是索引的前导列，但查询中没有指定 `region` 的条件。
*   `product_id` 和 `order_date` 是索引的后续列，并且有过滤条件。

**没有索引跳跃（早期版本行为）：**
MySQL 优化器可能无法完全利用 `idx_region_prod_date` 索引，因为它不能从 `region` 列开始匹配。它可能会选择全表扫描，或者如果 `product_id` 上有单独索引，可能会使用该索引（并进行回表）。

**启用索引跳跃（MySQL 8.0+）：**
如果 `region` 列的唯一值数量不多（例如：只有 'East', 'West', 'North', 'South' 四个区域），MySQL 优化器可以执行以下操作：
1.  首先，扫描索引以找到 `region` 列的所有唯一值（例如：'East', 'West', 'North', 'South'）。
2.  然后，对于每个 `region` 的唯一值，优化器会“跳过” `region` 列，并对 `(product_id, order_date)` 部分执行一个独立的索引查找。
    *   对于 `region = 'East'`，查找 `product_id = 101 AND order_date >= '2025-01-01'`。
    *   对于 `region = 'West'`，查找 `product_id = 101 AND order_date >= '2025-01-01'`。
    *   依此类推。
3.  最终，将所有这些子查询的结果合并。

通过 `EXPLAIN` 语句可以查看查询计划中是否使用了索引跳跃，通常会在 `Extra` 列显示 `Using index for skip scan`。

**优势：**
索引跳跃避免了在不满足最左前缀原则时进行全表扫描，从而显著提高了这类查询的性能，尤其是在前导列的基数（唯一值数量）较低时。