当 MySQL 出现深分页时，即 `LIMIT offset, row_count` 中的 `offset` 值非常大时，数据库需要扫描大量的数据然后再跳过 `offset` 数量的行，这会导致查询性能急剧下降。以下是优化此类 SQL 查询的几种方法：

1.  **子查询优化（使用索引覆盖查找 ID 再关联）**
    这是最常用且有效的方法。它首先在子查询中利用索引快速定位到所需记录的 `id`，然后再通过 `id` 去主表或完整索引中获取所有列的数据。
    假设你的表有一个主键 `id` 并且有其他字段 `column1`, `column2`。

    ```sql
    -- filepath: /workspaces/zwrworld/面试/数据库/MySQL/深分页.md
    -- 优化前（慢）
    -- SELECT column1, column2 FROM your_table ORDER BY id LIMIT 100000, 10;

    -- 优化后
    SELECT t.column1, t.column2
    FROM your_table t
    INNER JOIN (
        SELECT id
        FROM your_table
        ORDER BY id
        LIMIT 100000, 10
    ) AS sub
    ON t.id = sub.id;
    ```
    **解释**：子查询 `SELECT id FROM your_table ORDER BY id LIMIT 100000, 10` 会非常快，因为它只需要扫描 `id` 索引（如果 `id` 是主键，通常是聚集索引的一部分，但如果它是一个单独的二级索引，并且 `id` 是索引的第一个或唯一列，它将是一个覆盖索引），然后只返回 10 个 `id`。外部查询再通过这 10 个 `id` 准确地获取到完整的行数据。

2.  **延迟关联（Delayed Join）**
    这种方法与子查询优化类似，但更强调了“延迟获取所有列”的概念。如果 `ORDER BY` 的列有索引，可以先用该索引进行分页，再关联回原表。

    ```sql
    -- filepath: /workspaces/zwrworld/面试/数据库/MySQL/深分页.md
    SELECT t.column1, t.column2
    FROM your_table AS t,
    (SELECT id FROM your_table ORDER BY id LIMIT 100000, 10) AS sub
    WHERE t.id = sub.id;
    ```
    这与上面的子查询本质相同，只是写法略有不同。关键在于 `ORDER BY` 的列需要有索引。

3.  **书签法 / 范围查询（Bookmark Method / Range Query）**
    如果你的分页是“下一页/上一页”的模式，而不是“跳到第 N 页”，那么可以使用这种方法。它避免了 `OFFSET` 的使用，而是利用 `WHERE` 子句和索引来指定起始位置。

    ```sql
    -- filepath: /workspaces/zwrworld/面试/数据库/MySQL/深分页.md
    -- 假设你已经获取了上一页的最后一条记录的 id (last_id)
    SELECT column1, column2
    FROM your_table
    WHERE id > last_id
    ORDER BY id
    LIMIT 10;
    ```
    **解释**：这种方法不需要扫描和跳过大量行，直接从 `last_id` 的位置开始读取，效率非常高，因为它利用了 `id` 上的索引进行范围查找。前提是需要客户端保存上一页的最后一条记录的 ID 或其他排序字段。对于多条件排序，需要更复杂的 `WHERE` 子句。

4.  **限制查询总页数**
    在业务层面，可以考虑限制用户能够跳转到的最大页数。例如，只允许用户查看前 100 页或前 1000 条记录。这从产品设计上规避了深分页的问题。

5.  **冗余或缓存**
    对于频繁访问的深分页数据，可以考虑将部分结果冗余到其他表中，或者使用缓存系统（如 Redis）来存储分页数据。

6.  **利用搜索引擎**
    对于非常庞大的数据集和复杂的查询条件（包括全文搜索、多字段排序等），专业的搜索引擎（如 Elasticsearch, Solr）在分页查询方面通常比关系型数据库表现更好。它们天生为高性能的搜索和聚合设计。

**总结**
最常用且推荐的优化方法是**子查询优化（方法 1）**和**书签法（方法 3）**。在实际应用中，应根据业务场景和对性能、数据一致性的要求选择合适的策略。