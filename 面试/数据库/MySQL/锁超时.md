排查 MySQL 锁超时通常涉及以下步骤：

1.  **查看 MySQL 错误日志**
    检查 MySQL 错误日志文件（通常在 `datadir` 目录下，名为 `hostname.err`），查找包含 `Lock wait timeout exceeded` 或 `Deadlock found` 的错误信息。这可以提供锁超时的直接证据以及可能涉及的事务信息。

2.  **`SHOW ENGINE INNODB STATUS`**
    执行 `SHOW ENGINE INNODB STATUS;` 命令。在输出中，关注以下部分：
    *   `LATEST DETECTED DEADLOCK`：如果发生了死锁，这里会详细列出涉及的事务、锁和 SQL 语句。
    *   `TRANSACTIONS`：查看当前活跃的事务，特别是那些处于 `LOCK WAIT` 状态的事务。它们通常会显示正在等待的锁类型和正在持有锁的事务。
    *   `SEMAPHORES`：有时高并发下的锁竞争会体现在这里。

3.  **`information_schema.innodb_trx` 表**
    查询 `information_schema.innodb_trx` 表可以获取当前所有 InnoDB 事务的详细信息。
    ```sql
    SELECT
        trx_id,
        trx_state,
        trx_started,
        trx_requested_lock_id,
        trx_wait_started,
        trx_query,
        trx_mysql_thread_id
    FROM
        information_schema.innodb_trx
    WHERE
        trx_state = 'LOCK WAIT';
    ```
    这会显示正在等待锁的事务，以及它们正在等待的锁 ID 和正在执行的查询。

4.  **`information_schema.processlist` 或 `SHOW PROCESSLIST`**
    ```sql
    SHOW FULL PROCESSLIST;
    ```
    或
    ```sql
    SELECT * FROM information_schema.processlist WHERE state = 'Locked';
    ```
    这个命令可以显示所有正在运行的 MySQL 进程。关注 `State` 列为 `Locked`、`Waiting for table metadata lock` 或长时间处于 `Sending data` 等状态的进程。结合 `Time` 列，可以识别长时间运行或被阻塞的查询。

5.  **识别阻塞事务**
    结合 `innodb_trx` 和 `processlist` 的信息，可以尝试找出哪个事务持有了锁，导致其他事务超时。
    *   从 `innodb_trx` 找到 `LOCK WAIT` 状态的 `trx_id` 和 `trx_requested_lock_id`。
    *   然后通过 `innodb_locks` 和 `innodb_lock_waits` 表（在旧版本中可能需要 `innodb_locks` 和 `innodb_lock_waits` 联合查询，但在新版本中通常通过 `innodb_trx` 即可获取更多信息）来追踪哪个事务正在持有这个锁。
    *   或者，更直接地，通过 `trx_mysql_thread_id` 关联到 `processlist` 中的 `Id`，查看阻塞事务正在执行的 SQL。

6.  **分析 SQL 语句和索引**
    一旦识别出导致锁竞争的 SQL 语句，需要对其进行分析：
    *   **缺少索引**：在 WHERE 子句、JOIN 条件或 ORDER BY 子句中缺少适当的索引会导致全表扫描或全索引扫描，从而增加锁的范围和时间。
    *   **大事务**：长时间运行的事务会持有锁更长时间，增加冲突的可能性。尝试将大事务拆分成小事务。
    *   **低效查询**：例如，在更新操作中使用 `SELECT ... FOR UPDATE` 但条件不精确，或者在事务中执行大量复杂查询。
    *   **锁粒度**：InnoDB 通常使用行级锁，但在某些情况下（例如外键约束操作、全文索引操作、某些 DDL 操作）可能会升级为表级锁。

7.  **调整 `innodb_lock_wait_timeout`**
    这个参数定义了事务等待锁的超时时间（默认为 50 秒）。如果频繁出现锁超时，可以考虑适当增加或减少这个值。
    *   **增加**：如果业务逻辑确实需要较长的锁等待时间，可以增加以减少超时报错，但可能导致事务长时间阻塞。
    *   **减少**：如果希望快速发现并终止长时间阻塞的事务，可以减少它。

    可以通过以下命令查看当前值：
    ```sql
    SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';
    ```
    可以通过以下命令临时修改（会话级别）：
    ```sql
    SET SESSION innodb_lock_wait_timeout = 100; -- 设置为100秒
    ```
    或者在 `my.cnf` 中永久修改：
    ```ini
    # filepath: /etc/mysql/my.cnf (or similar)
    [mysqld]
    innodb_lock_wait_timeout = 100
    ```
    然后重启 MySQL 服务。

通过上述步骤，您应该能够定位到导致 MySQL 锁超时的具体原因并采取相应的优化措施。